# Разбор комментариев Мурыча по поводу возможности обращаться из WASM к canvas напрямую.

## Контекст

Было несколько видео подряд, в которых Мурыч упомянал в одном предложении связку wasm / canvas.
Примеры: 

* 
* 
* 

На одном из стримов я задал вопрос, но не получил ответа. Спросил в общем чате знает ли кто, что точно имел в виду Мурыч.
https://t.me/AsForJsTalks/25649

Дмитрий гуляев обещал задать этот вопрос Мурычу https://t.me/AsForJsTalks/25650

Переписка с Дмитрием Гуляевым: (Я получил )

> Дмитрий Гуляев:
"переслано от Demi Murych"

https://radu-matei.com/blog/practical-guide-to-wasm-memory/
https://wasmbyexample.dev/examples/reading-and-writing-graphics/reading-and-writing-graphics.rust.en-us.html
https://github.com/ern0/howto-wasm-minimal
https://github.com/daneelsan/minimal-zig-wasm-canvas

> Cтепан Михайлюк:

Привет. Спасибо. Это как раз то о чем я говорил. Мурыч в своих видео говорил о том что появился способ обращения к канвасу из wasm. По ссылкам он прислал просто обычное чтение памяти снаружи. Тоесть wasm просто пишет в uint8array

> Дмитрий Гуляев
перешлю мурычу

> Дмитрий Гуляев: "переслано от Demi Murych"
Конечно, только раньше нельзя было читать и пасть туже паамять что и память для canvas

> Дмитрий Гуляев: "переслано от Demi Murych"
теперь это делать можно

Далее Мурыч написал мне сам.

Переписка с Мурычем (я получил разрешение от Мурыча на публикацию переписки):

> тебе уже передали ссылки на то что касается canvas и wasm
> Перезапись нужной области памяти приводит к обновлению canvas
> Это эксплуатируется уже с год как.


## Мои сомнения по технической части вопроса

* В спецификации WASM нет ни слова про canvas и быть не может, так как WASM может работать в хост системе где не поддерживается HTMLCanvasElement, который описан в спецификации HTML5

* Если обстрагироваться от WASM, В canvas api, самом по себе, не существует такого api при котором перезапись нужной области памяти приводит к обновлению отображения canvas.
Насколько мне известно. В приведенных Мурычем ссылках нет конкретики, о каком API говорится.

Насколько мне известно,
Существует единственный способ нарисовать что-то на 2d canvas, используя как источник данных набор пикселей.

Пример:

```js
var width = 1920;
var height = 1080;
var pixels = new Uint8Array(width * height * 4);
var imageData = new ImageData(pixels, width, height);

var canvas = document.createElement('canvas');
var ctx = canvas.getContext('2d');

ctx.putImageData(imageData);
```

Можно сказать что, в этом примере, определенная область памяти перезаписывается, что приводит canvas к перерисовке, что кажется совпадает с формулировкой Мурыча.
Но!
Обратите внимание что, если мутировать данные внутри typedArray - это не приведет к обновлению отображения.
Согласно спецификации `CanvasRenderinContext2d`,
мы всегда должны вызывать ctx.putImageData явно, если хотим обновить представление.

Этот же пример, с putImageData используется в гайдах, который прислал Мурыч.
Это говорит о том, что нет никакого прямого доступа к памяти, которая связана с отображением.

Если бы такой API существовал он бы выглядел скорее всего вот так

```js
var pixels = new Uint8Array(1920*1080*4);

ctx.bindRenderBuffer(pixels, { colorSpace: 'srgb' });

// update pixels data triggers canvas update
pixels.set([255, 1, 1, 0], 4 * 100);
```

На вскидку (Не берусь утверждать), одна из возможных причин почему такой API не предоставлен кроется в том, что размер можно менять согласно спецификации HTML5. Чтобы обработать такую ситуацию необходимо выдать исключение при обращении к буферу, чтобы пользователь иницилизировал новый и сделал байндинг.

### Скорее всего, мурыч имеет в виду немного другое:
С момента первой имплементации WASM была возможность сформировать pixels внутри WASM передать упрвление коду js

Релиз хрома
57 (Released 2017-03-09)

Только

https://t.me/AsForJsTalks/14883 рассказ про google docs
